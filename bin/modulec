#!/bin/bash

set -e

declare VERBOSE=false

function Fail {
    printf "$*"
    echo
    exit 1
}

function Run {
    local command="$1"
    shift

    if $VERBOSE
    then
        printf "%q" "$command"
        printf " %q" "$@"
        printf "\\n"
    fi

    if "$command" "$@"
    then
        return 0
    else
        return $?
    fi
}

function Help {
    cat <<EOF
Usage: modulec [OPTION...] SRC [-- JAVAC_ARG...]
Make a modular JAR from the Java module source in SRC.

Options:
  -d CLASSDIR             The directory to write the compiled class files to.
                          By default, a temporary directory will be used.
  -e,--main-class CLASS   Specify the main class of the module.
  -f,--file JARPATH       The path to the modular JAR file. If JARPATH is a
                          directory, the modular JAR will be written to that
                          directory with a filename NAME[-VERSION].jar. If
                          NAME has not been set with --name, it is extracted
                          from module-info.class with javap after compilation.
                          By default JARPATH is the current directory.
  -m,--manifest MANIFEST  Include the manifest info from MANIFEST
  -n,--name NAME          Sets the name of the module AND trigger compilation
                          optimization (see below).
  -p,--module-path MPATH  Set the module path for compilation, empty by default.
                          This option is folded into JAVAC_ARG.
  -v,--version VERSION    Set the module version.

modulec first compiles the *.java files under SRC (JAVA_FILE...), with
    javac -d CLASSDIR [--module-version VERSION] [JAVAC_ARG...] JAVA_FILE...

However if --name has been specified, the source is instead compiled using
--module-source-path and --module, which should be faster (with -d).

Then the modular JAR is made with
    jar -c -f JARPATH [--main-class CLASS] -C CLASSDIR .

Prefers javac, jar, and javap below JAVA_HOME if set.

Example: Say the 'src' directory contains module-info.java, defining module
'mod', and foo/Bar.java. Then
    modulec src
will make a 'mod.jar' modular JAR. But it is recommended to use -d and -n:
    modulec -d classes -n mod src
which may be considerable faster on subsequent compilations.
EOF

    exit 1
}

function Main {
    local src=
    local classdir=
    local -a main_class=()
    local jarpath=.
    local -a module_path=()
    local version_suffix=
    local -a module_version=()
    local name=

    (( $# > 0 )) || Help

    while (( $# > 0 ))
    do
        case "$1" in
            -d)
                classdir="$2"
                shift 2
                ;;
            -e|--main-class)
                main_class=("$1" "$2")
                shift 2
                ;;
            -f|--file)
                jarpath="$2"
                shift 2
                ;;
            --help|-h)
                Help
                ;;
            -n|--name)
                name="$2"
                shift 2
                ;;
            -p|--module-path)
                module_path=("$1" "$2")
                shift 2
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            -v|--version)
                version_suffix="-$2"
                module_version=(--module-version "$2")
                shift 2
                ;;
            -*)
                Fail "Unknown option '$1'"
                ;;
            *)
                src="$1"
                shift
                break
                ;;
        esac
    done

    local classdir_is_tmp=false
    if test "$classdir" == ""
    then
        classdir_is_tmp=true
        # Will create directory of the form /tmp/modulec-hakon.d7R47C8zIX
        classdir=$(mktemp -d --tmpdir modulec-"$USER".XXXXXXXXXX)
    fi

    test "$src" != "" || Fail "No source directory specified!"
    test -d "$src" || Fail "'$src' is not a directory!"
    test -r "$src"/module-info.java || \
        Fail "'$src' does not contain a module-info.java file!"

    if (( $# > 0 ))
    then
        test "$1" == -- || Fail "Expected '--' but found '$1'"
        shift
    fi

    local -a javac_args=("$@")

    local javac=javac
    local javap=javap
    local jar=jar
    # The OS installed javac may be out of date
    if test "$JAVA_HOME" != "" && test -x "$JAVA_HOME"/bin/javac
    then
        javac="$JAVA_HOME"/bin/javac
        javap="$JAVA_HOME"/bin/javap
        jar="$JAVA_HOME"/bin/jar
    fi

    type "$javac" &> /dev/null || Fail "'javac' is not installed"
    type "$jar" &> /dev/null || Fail "'jar' is not installed"

    if test "$name" != ""
    then
        # This strategy removes need to find all *.java files. Also, it checks
        # timestamps to figure out which *.java file to compile. Thus --name
        # does not make much sense without -d.
        #
        # Future improvement with Java 12, it is possible to specify
        # '--module-source-path NAME=SRC', where NAME is the module name, and
        # SRC is the path to the root of the module source tree. Unfortunately,
        # the output is still put under outputdir/NAME.

        local tmpdir=
        tmpdir=$(mktemp -d)
        mkdir -p "$tmpdir"/classes "$tmpdir"/src
        local absolute_src=$(realpath "$src")
        mkdir -p "$classdir"
        local absolute_classdir=$(realpath "$classdir")

        ln -s "$absolute_src" "$tmpdir"/src/"$name"
        ln -s "$absolute_classdir" "$tmpdir"/classes/"$name"

        if Run "$javac" -d "$tmpdir"/classes "${module_version[@]}" \
               --module-source-path "$tmpdir"/src --module "$name" \
               "${module_path[@]}" "${javac_args[@]}"
        then
            rm -r "$tmpdir"
        else
            local exit_code=$?
            rm -r "$tmpdir"
            exit $exit_code
        fi
    else
        if Run "$javac" -d "$classdir" "${module_version[@]}" \
               "${module_path[@]}" "${javac_args[@]}" \
               $(find "$src" -name '*.java')
        then
            :
        else
            exit $?
        fi
    fi

    if test -d "$jarpath"
    then
        if test "$name" == ""
        then
            type "$javap" &> /dev/null || Fail "'javap' is not installed"

            local output=
            output=$("$javap" "$classdir"/module-info.class)

            while read -r
            do
                if [[ "$REPLY" =~ ^'module '([^@\ ]+) ]]
                then
                    name="${BASH_REMATCH[1]}"
                    break
                fi
            done <<< "$output"

            if test "$name" == ""
            then
                ! $classdir_is_tmp || rm -r "$classdir"
                Fail "Failed to find module name from module descriptor"
            fi
        fi

        jarpath+=/"$name$version_suffix".jar
    fi

    if Run "$jar" -c -f "$jarpath" "${main_class[@]}" -C "$classdir" .
    then
        local exit_code=$?
    else
        local exit_code=$?
    fi
    ! $classdir_is_tmp || rm -r "$classdir"
    (( exit_code == 0 )) || exit $exit_code
}

Main "$@"
