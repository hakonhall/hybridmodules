#!/bin/bash

set -e

declare VERBOSE=false

function Fail {
    printf "$*"
    echo
    exit 1
}

function Run {
    local command="$1"
    shift

    if $VERBOSE
    then
        printf "%q" "$command"
        printf " %q" "$@"
        printf "\\n"
    fi

    if "$command" "$@"
    then
        return 0
    else
        return $?
    fi
}

function Help {
    cat <<EOF
Usage: modulec [OPTION...] SRC [-- JAVAC_ARG...]
Make a modular JAR from the Java module source in SRC.

Options:
  -d CLASSDIR             The directory to write the compiled class files to.
                          By default, a temporary directory will be used.
  -D BUILDDIR             Same as '-d BUILDDIR/classes -f BUILDDIR/'.
  -e,--main-class CLASS   Specify the main class of the module. If CLASS starts
                          with a dot (.), the main class is prefixed with NAME.
  -f,--file JARPATH       The path to the modular JAR file. If JARPATH ends with
                          /, it is created as a directory if it does not exists.
                          If JARPATH is a directory, the modular JAR will be
                          written to that directory with a filename
                          NAME[-VERSION].jar.  By default JARPATH is the
                          current directory.
  -m,--manifest MANIFEST  Include the manifest information from MANIFEST file.
  -n,--name NAME          Provides the module name when it cannot be figured out
                          from module-info.java trivially.
  -p,--module-path MPATH  Set the module path for compilation, empty by default.
                          This option is folded into JAVAC_ARG.
  -v,--version VERSION    Set the module version.

modulec first compiles the module NAME with source files in SRC using
--module-source-path and --module NAME, to class files below CLASSDIR:

    javac --module-source-path TMPSRC --module NAME -d CLASSDIR \\
          [--module-version VERSION] [JAVAC_ARG...]

TMPSRC is a temporary directory containing a symlink NAME that points to SRC.
These temporaries can be avoided from Java 12 using --module-source-path
NAME=SRC syntax.

Next, the modular JAR is made with:

    jar -c -f JARPATH [--main-class CLASS] -C CLASSDIR .
EOF

    exit 1
}

function Main {
    local src=
    local classdir=
    local -a main_class=()
    local jarpath=.
    local -a module_path=()
    local version_suffix=
    local -a module_version=()
    local name=

    (( $# > 0 )) || Help

    while (( $# > 0 ))
    do
        case "$1" in
            -d)
                classdir="$2"
                shift 2
                ;;
            -D)
                local builddir="$2"
                shift 2
                set -- -d "$builddir"/classes -f "$builddir"/ "$@"
                ;;
            -e|--main-class)
                main_class=("$1" "$2")
                shift 2
                ;;
            -f|--file)
                jarpath="$2"
                shift 2
                ;;
            --help|-h)
                Help
                ;;
            -n|--name)
                name="$2"
                shift 2
                ;;
            -p|--module-path)
                module_path=("$1" "$2")
                shift 2
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            -v|--version)
                version_suffix="-$2"
                module_version=(--module-version "$2")
                shift 2
                ;;
            -*)
                Fail "Unknown option '$1'"
                ;;
            *)
                src="$1"
                shift
                break
                ;;
        esac
    done

    local classdir_is_tmp=false
    if test "$classdir" == ""
    then
        classdir_is_tmp=true
        # Will create directory of the form /tmp/modulec-hakon.d7R47C8zIX
        classdir=$(mktemp -d --tmpdir modulec-"$USER".XXXXXXXXXX)
    fi

    test "$src" != "" || Fail "No source directory specified!"
    test -d "$src" || Fail "'$src' is not a directory!"
    test -r "$src"/module-info.java || \
        Fail "'$src' does not contain a module-info.java file!"

    local newline=$'\n'
    if test "$name" == ""
    then
        # Heuristic getting the module name.
        [[ $(< "$src"/module-info.java) =~ (^|$newline)module' '+([a-zA-Z0-9._]+) ]] || \
            Fail "Failed to read module name from $src/module-info.java, " \
                 "please provide it with --name"
        name="${BASH_REMATCH[2]}"
    fi

    # Resolve relative main class name
    if (( ${#main_class[@]} > 0 )) && test "${main_class[1]:0:1}" == .
    then
        main_class[1]="$name${main_class[1]}"
    fi

    if (( $# > 0 ))
    then
        test "$1" == -- || Fail "Expected '--' but found '$1'"
        shift
    fi

    local -a javac_args=("$@")

    # Fall back to JAVA_HOME if not in PATH.
    if ! type javac &> /dev/null && \
                test "$JAVA_HOME" != "" && \
                test -x "$JAVA_HOME"/bin/javac
    then
        PATH="$JAVA_HOME"/bin:"$PATH"
    fi

    type java &> /dev/null || Fail "'java' is not installed"
    type javac &> /dev/null || Fail "'javac' is not installed"
    type jar &> /dev/null || Fail "'jar' is not installed"

    # This strategy removes need to find all *.java files. Also, it checks
    # timestamps to figure out which *.java file to compile. Thus --name
    # does not make much sense without -d.
    #
    # Future improvement with Java 12, it is possible to specify
    # '--module-source-path NAME=SRC', where NAME is the module name, and
    # SRC is the path to the root of the module source tree. Unfortunately,
    # the output is still put under outputdir/NAME.

    local tmpdir=
    tmpdir=$(mktemp -d)
    mkdir -p "$tmpdir"/classes "$tmpdir"/src
    local absolute_src=$(realpath "$src")
    mkdir -p "$classdir"
    local absolute_classdir=$(realpath "$classdir")

    ln -s "$absolute_src" "$tmpdir"/src/"$name"
    ln -s "$absolute_classdir" "$tmpdir"/classes/"$name"

    if Run javac -d "$tmpdir"/classes "${module_version[@]}" \
           --module-source-path "$tmpdir"/src --module "$name" \
           "${module_path[@]}" "${javac_args[@]}"
    then
        rm -r "$tmpdir"
    else
        local exit_code=$?
        rm -r "$tmpdir"
        exit $exit_code
    fi

    if [[ "$jarpath" =~ /$ ]]
    then
        jarpath="${jarpath%/}"
        test -d "$jarpath" || mkdir -p "$jarpath"
    fi

    if test -d "$jarpath"
    then
        jarpath+=/"$name$version_suffix".jar
    fi

    if Run jar -c -f "$jarpath" "${main_class[@]}" -C "$classdir" .
    then
        local exit_code=$?
    else
        local exit_code=$?
    fi
    ! $classdir_is_tmp || rm -r "$classdir"
    (( exit_code == 0 )) || exit $exit_code
}

Main "$@"
